{% load staticfiles %}

<!DOCTYPE html>
<html lang="en">
  
  <head>

    <title>H1 Report for {{ member }}</title>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="http://keen.github.io/dashboards/assets/css/keen-dashboards.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js"></script>
    <script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

    <link rel="stylesheet" href="https://cdn.pydata.org/bokeh/release/bokeh-0.12.0.min.css" type="text/css" />
    <link rel="stylesheet" href="https://cdn.pydata.org/bokeh/release/bokeh-widgets-0.12.0.min.css" type="text/css" />

    <script type="text/javascript" src="https://cdn.pydata.org/bokeh/release/bokeh-0.12.0.min.js"></script>
    <script type="text/javascript" src="https://cdn.pydata.org/bokeh/release/bokeh-widgets-0.12.0.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.js"></script>
    
    {{ satisfaction_script|safe }}
    {{ participation_script|safe }}
    
    <style>      
      .fixed-max-width {
      margin: 0 auto;
      }
      body {
      max-width: 1300px;
      margin: 0 auto;
      }
      .chart-wrapper .chart-title {
      background: #fbfbfb;
      }
      .chart-wrapper .chart-notes {
      font-size: 18px;
      }
      .height {
      min-height: 250px;
      }
      footer {
      background-color: white;
      color: black;
      padding: 15px;
      font-size: 18px;
      border: 1px solid #e2e2e2;
      border-radius: 3px;
      margin-bottom: 10px;
      }
      img {
      max-width:100%;
      max-height:100%;
      }
      .keen-metric { 
      background: steelblue; 
      display: block-inline;
      border-radius: 4px; 
      color: #fff; 
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; 
      padding: 10px 0;
      margin: 10px; 
      text-align: center;
      }
      .keen-metric-value { 
      display: block; 
      font-size: 60px; 
      font-weight: 700; 
      line-height: 84px; 
      }
      .keen-metric-title { 
      display: block; 
      font-size: 24px; 
      font-weight: 200; 
      }
      
      .node {
      stroke: #fff;
      stroke-width: 1.5px;
      }
      .link {
      stroke: #999;
      stroke-opacity: .6;
      }
      path.link {
      fill: none;
      stroke: #000;
      stroke-width: 4px;
      cursor: default;
      }
    </style>
    
  </head>

  <body class="application">

    <img src="/static/img/media_lab_logo.png" alt="" height="100" width="170">

    <div class="container-fluid fixed-max-width">

      <h1>H1 Report for {{ member }}</h1>
      
      <div class="row">

	<div class="col-sm-12" id="percentage_participation">
	  <div class="chart-wrapper">
	    <div class="chart-title">
	      <h3>Percentage of Participation for {{ group }}</h3>
	    </div>
	    <div class="chart-stage">
	      {{ participation_div|safe }}
	    </div>
	    <div class="chart-notes">
	      The percentage of participation per member per week, as well as the percentage of participation for all weeks. Participation can be determined by either the number of speaking turns or the amount of time spent speaking. The red rectangles show which weeks had visualization enabled.
	    </div>
	  </div>
	</div>
	
      </div>

      <!--
      <div class="row">

	<div class="col-sm-12" id="bar1">
	  <div class="chart-wrapper">
	    <div class="chart-title">
	      <h3>Participation Over Time</h3>
	    </div>
	    <div class="chart-stage">
	      <img src="/media/{{paths.daily_meeting_time}}">
	    </div>
	    <div class="chart-notes">
	      Cool stacked area graph.
	    </div>	    
	    </div>
	  </div>
	</div>

      </div>
      -->

      <div class="row">

	<div class="col-sm-12" id="bar2">
	  <div class="chart-wrapper">
	    <div class="chart-title">
	      <h3>Transitions</h3>
	    </div>
	    <div class="chart-stage" id="transition-matrix">
	      <!--
	      <script src="/static/js/curved-graph2.js"></script>
	      -->
	      <script type="text/javascript">

//function makeScript(fileName) {
function makeScript(graph) {
		
var width = 800,
    height = 500;

var color = d3.scale.category20();

var radius = d3.scale.linear()
    .domain([0, 26])
    .range([30, 60])

var edgeWeight = d3.scale.linear()
    .domain([1, 30])
    .range([1.5, 8])


var force = d3.layout.force()
    .charge(-120)
    .linkDistance(width*.35)
    .size([width, height])

var svg = d3.select("#transition-matrix").append("svg")
    .attr("width", width)
    .attr("height", height);


// define arrow markers for graph links
svg.append('svg:defs').append('svg:marker')
    .attr('id', 'end-arrow')
    .attr('viewBox', '0 -5 10 10')
    .attr('refX', 9)
    .attr('refY', 0)
    .attr('markerWidth', 5)
    .attr('markerHeight', 5)
    .attr('orient', 'auto')
    .append('svg:path')
    .attr('d', 'M0,-5L10,0L0,5')
    .attr('fill', '#000')
    .attr('markerUnits', '5');

//d3.json(fileName, function(error, graph) {
    
    //if (error) throw error;

    /*
    force.linkDistance(function(){
	var count = 0
	for (var i=0, n=graph.nodes.length; i<n; i++)
	{
	    count += graph.nodes[i].value;
	}
	console.log(count);
	return width*count/250+100;
    });
    */    

    force
	.nodes(graph.nodes)
	.links(graph.edges)
	.start();
    
    var link = svg.selectAll('.link')
        .data(graph.edges)
        .enter().append('svg:path')
        .attr('class', 'link')
      //.style('marker-start', function(d) { return d.left ? 'url(#start-arrow)' : ''; })
        .style('marker-end', function(d) { return 'url(#end-arrow)'; })
        .style("stroke-width", function(d) { return edgeWeight(d.weight); })
	.style("stroke-opacity", ".5");
    
    var node = svg.selectAll(".node")
        .data(graph.nodes)
	.enter().append("g")
	.attr("class", "node")
	.call(force.drag);
    
    node.append("circle")
	.attr("r", function (d) {
	    return radius(d.value); })
        .style("fill", function(d) { return color(d.name); });
    
    
    node.append("title")
	.text(function(d) { return d.name + ": " + d.value + "% speaking turns"; });
    
    node.append("text")
//	.text(function(d) {return d.name})
//	.attr("dx", function(d) { return (-0.1)*radius(d.value)*d.name.length })
	.text(function(d) { return d.name.split(" ")[0] })
	.attr("dx", function(d) { return (-0.1)*radius(d.value)*1.4*d.name.split(" ")[0].length })
	.attr("font-size", function(d) { return d.value+8 })
//      .attr("fill", "white");
	.attr("color", "gray")
	.attr("text-shadow", "gray");
    
    node.append("text")
    	.text(function(d) { return d.name.split(" ")[1].charAt(0)+"." })
	.attr("dx", function(d) { return (-0.1)*radius(d.value)*d.name.split(" ")[1].length })
	.attr("dx", function(d) { return (-0.05)*radius(d.value) })
	.attr("dy", "1em")
	.attr("font-size", function(d) { return d.value+8 })
//      .attr("fill", "white");

    //Node Highlighting: (taken from http://www.coppelia.io/2014/07/an-a-to-z-of-extra-features-for-the-d3-force-layout/)
    node.on('dblclick', connectedNodes);
    //Double-click on a node to fade out all but its immediate neighbours.
    //Double-click to bring them back again.
    //Toggle stores whether the highlighting is on
    var toggle = 0;
    //Create an array logging what is connected to what
    var linkedByIndex = {};
    for (i = 0; i < graph.nodes.length; i++) {
	linkedByIndex[i + "," + i] = 1;
    };
    graph.edges.forEach(function (d) {
	linkedByIndex[d.source.index + "," + d.target.index] = 1;
    });
    //This function looks up whether a pair are neighbours
    function neighboring(a, b) {
	return linkedByIndex[a.index + "," + b.index];
    }
    function connectedNodes() {
	if (toggle == 0) {
            //Reduce the opacity of all but the neighbouring nodes
            d = d3.select(this).node().__data__;
            node.style("opacity", function (o) {
		return neighboring(d, o) | neighboring(o, d) ? 1 : 0.1;
            });
            link.style("opacity", function (o) {
		return d.index==o.source.index | d.index==o.target.index ? 1 : 0.1;
            });
            //Reduce the op
            toggle = 1;
	} else {
            //Put them back to opacity=1
            node.style("opacity", 1);
            link.style("opacity", 1);
            toggle = 0;
	}
    }

//Making sure nodes don't overlap: (taken from http://www.coppelia.io/2014/07/an-a-to-z-of-extra-features-for-the-d3-force-layout/)
var padding = 1; // separation between circles
function collide(alpha) {
  var quadtree = d3.geom.quadtree(graph.nodes);
  return function(d) {
      var rb = 2*radius(d.value) + padding,
        nx1 = d.x - rb,
        nx2 = d.x + rb,
        ny1 = d.y - rb,
        ny2 = d.y + rb;
    quadtree.visit(function(quad, x1, y1, x2, y2) {
      if (quad.point && (quad.point !== d)) {
        var x = d.x - quad.point.x,
            y = d.y - quad.point.y,
            l = Math.sqrt(x * x + y * y);
          if (l < rb) {
          l = (l - rb) / l * alpha;
          d.x -= x *= l;
          d.y -= y *= l;
          quad.point.x += x;
          quad.point.y += y;
        }
      }
      return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
    });
  };
}
		    
    link.append("title")
	.text(function(d) { return d.source.name + " -> " + d.target.name + ": " + d.weight + "% transitions"; });    
    
    
    // Use elliptical arc path segments to doubly-encode directionality.
    force.on("tick", function () {
	link.attr("d", linkArc);
	node.attr("transform", transform);
	//text.attr("transform", transform);
	node.each(collide(0.4));
    })
    
    function linkArc(d) {
	var dx = d.target.x - d.source.x,
            dy = d.target.y - d.source.y,
            dr = Math.sqrt(dx * dx + dy * dy)*.75,
            dist = Math.sqrt(dx * dx + dy * dy),
            normX = dx / dist,
            normY = dy / dist,
            targetPadding = radius(d.target.value) + 1,
            sourcePadding = radius(d.source.value),
            sourceX = d.source.x + (sourcePadding * normX),
            sourceY = d.source.y + (sourcePadding * normY),
            targetX = d.target.x - (targetPadding * normX),
            targetY = d.target.y - (targetPadding * normY);
	return "M" + sourceX + "," + sourceY + "A" + dr + "," + dr + " 0 0,1 " + targetX + "," + targetY;
    }
    
    function transform(d) {
	return "translate(" + d.x + "," + d.y + ")";
    }
    
//});
		    
}

//makeScript("{{transition_file_name}}");
makeScript({{graph|safe}});
		    
	      </script>
	    </div>
	    <div class="chart-notes">
	      Here, we have each circle representing a participant, with circle sizes representing participation, i.e. number of speaking turns throughout the whole study.<br>
	      Arrows represent the probability of participant A responding to participant B. Double-click on a circle to see only the arrows relating to the participant.<br>
	    </div>
	  </div>
	</div>

      </div>

      <div class="row">
	<div class="col-sm-12" id="aggregate_daily_plot">
	  <div class="chart-wrapper">
	    <div class="chart-title">
	      <h3>Satisfaction vs. Participation</h3>
	    </div>
	    <div class="chart-stage">
	      {{ satisfaction_div|safe }}
	      
	      <div class="bk-root"> <div class="plotdiv" id="5066d1c9-7c8a-4275-b4a4-d62ddd7bf3df"></div> </div>

	      
	    </div>
	    <div class="chart-notes">
	      The level of satisfaction (based on the survey) and the level of engagement or participation for each week.<br>
	      Outcome: How satisfied you were with the outcome of the meetings.<br>
	      Process: How satisfied you were with the process of the meetings.<br>
	      Value: How valuable you thought your perspective was to the meetings.<br>
	      Comfort: How comfortable you were in sharing your perspective with the team.<br>
	      Average: Average of the four above values.
	    </div>
	  </div>
	</div>
      </div>

    </div>

    <footer>
      Thank you for your participation.
    </footer>
    <br>

  </body>

</html>

